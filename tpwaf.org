#+TITLE: TP Waf
#+STYLE: <link rel="stylesheet" type="text/css" href="org.css" />


* Introduction

Waf est un outil de construction de logiciel, dans la lignée des
autotools (configure, make), cmake, scons. Il permet de gérer la
configuration, la compilation et l'installation d'un logiciel avec une
syntaxe intuitive (en python), et des fonctionnalités (modules)
permettant d'écrire les scripts de construction très rapidement, quel
que soit le langage utilisé. 

Cette structure modulaire permet aux utilisateurs d'en étendre les
fonctionnalités selon leur besoin, et ainsi de s'adapter à la
complexité croissante des processus de construction (multiplicité des
langages, des architectures, interfaçage , etc). 

Waf est performant, portable, léger, et directement distribué avec
l'application qu'il construit, il ne requiert donc aucune installation
préalable. 

Ce TP a pour objectif de vous guider dans : 

+ l'écriture d'un simple script de construction incluant la
  configuration (mise en place d'options), la compilation (utilisant
  les fonctionnalités de compilation C/C++, Fortran et python) et
  l'installation.
+ l'utilisation de waf dans le cadre d'une application (performances
  et gestion des dépendances)
+ l'écriture d'extensions


* Concepts de base

** Le binaire waf

Waf est distribué avec l'application qu'il construit sous la forme
d'un binaire nommé =waf= embarquant l'ensemble des fonctionnalités de
base de l'outil. \\
Les directives propres au logiciel qu'il construit sont écrites dans
un script nommé =wscript=. \\
L'ensemble des commandes du binaire sont documentées et accessibles à
l'utilisateur: 

#+BEGIN_SRC shell
./waf --help
#+END_SRC

#+BEGIN_VERSE
Ouvrir une fenêtre de commande, extraire l'archive jointe au TP et définir un alias pour l'ensemble du TP =alias waf=$PWD/waf=. 
Exécuter la commande ci-dessus pour obtenir la liste des commandes.
#+END_VERSE

La construction classique d'un outil passe par : 

#+BEGIN_SRC shell
waf configure       (ref:1)
waf install         (ref:2)
#+END_SRC

[[(1)]] configuration de l'installation \\
[[(2)]] construction et installation de l'outil

Ces commandes correspondent à des fonctions Python, qui peuvent être (re)définies au sein du =wscript=

#+BEGIN_SRC Python
def version():
    return 1.1
#+END_SRC

#+BEGIN_SRC python
def configure(ctx):
    v = version()
    print 'version %f'%v
#+END_SRC
    
#+BEGIN_VERSE
Ouvrir le fichier =1/wscript= et ajouter ces lignes de code à la suite du header. 
Vérifier par la commande =waf configure= que vos modifications ont bien été intégrées.  
#+END_VERSE


** L'environnement de construction

Les fichiers de construction générés par =waf= sont enregistrés dans
le répertoire =.build=. Le script =wscript= est situé à la racine
du projet.

#+BEGIN_SRC shell
tree
#+END_SRC

Ces fichiers sont effacés automatiquement à l'appel de la commande =distclean=

#+BEGIN_SRC shell
waf distclean
tree
#+END_SRC

#+BEGIN_VERSE
Exécuter ces commandes dans l'order pour afficher le contenu du répertoire =build=. 
#+END_VERSE


Cette configuration par défaut peut être modifiée, en tête du =wscript= 

#+BEGIN_SRC Python
top = './'
out = './build'
#+END_SRC

Il est possible d'utiliser plusieurs fichiers =wscript=. L'appel à la
fonction =recurse= permet de les appeler. 

#+BEGIN_SRC Python
def configure(ctx):
    ctx.recurse('src')
#+END_SRC

#+BEGIN_VERSE
Observer le contenu du fichier =1/src/wscript=
Modifier la fonction =configure= de =1/wscript= pour exécuter ce nouveau script. 
#+END_VERSE

** Persistence des données

Les informations récupérées lors de la phase de configuration sont
stockées dans les objets =Context= , et sur disque dans un fichier de cache:

#+BEGIN_SRC Python
def configure(ctx):
    ctx.env.FOO = 'bar'
#+END_SRC

#+BEGIN_SRC shell
more build/c4che/_cache.py
#+END_SRC

#+BEGIN_VERSE
Ajouter la définition d'une nouvelle variable d'environnement à la fonction =configure= de =1/wscript=. 
Vérifier sa présence dans le fichier de cache. 
#+END_VERSE


** Ajouter de nouvelles options

L'ajout de nouvelles options de configuration est réalisé via la
définition d'une fonction nommées =options= qui prend un object
=Context= comme unique argument. Le mécanisme utilisé est celui du
paquet Python de référence =optparse=. 

#+BEGIN_SRC Python
def options(ctx):
        ctx.add_option('--myoption', action='store', default=False, help='this is my option')

def configure(ctx):
	ctx.ENV.MYOPT = ctx.options.myoption

def build(bld):
        print(bld.env.MYOPT)
#+END_SRC

#+BEGIN_VERSE
Ajouter la définition d'une fonction =options= à =1/wscript=. 
Exécuter la configuration puis la construction afin de vérifier la bonne propagation de votre option. 
#+END_VERSE

** Outils de configuration

La librairie =waf= dispose de quelques outils prêt à l'emploi
permettant d'analyser l'environnement de construction. En voici
quelques exemples:

#+BEGIN_SRC Python   
def configure(ctx):
    ctx.find_program('touch', var='TOUCH')
    ctx.check_waf_version(mini='1.6.11')
    try:
       ctx.find_file('fstab', ['/opt', '/etc'])  
    except ctx.errors.ConfigurationError:
       self.to_log('fstab was not found (ignoring)'

def build(ctx):
    print ctx.ENV.TOUCH
#+END_SRC

#+BEGIN_VERSE
Compléter le script avec ces instructions. 
Exécuter la configuration puis la construction afin de vérifier la compatibilité de votre environnement. 
#+END_VERSE

** Manipulation des objets =Context=

Comme mentionné précedemment, les variables d'environnement sont
stockées dans l'attribut =ctx.env=. Elles peuvent être accédées de
deux manières: par un mécanisme d'attribut =ctx.env.FOO= ou de
dictionnaire =ctx.env["foo"]=. Les variables en question sont
généralement des listes, qu'il convient de manipuler via la méthode
=append=. 

#+BEGIN_SRC Python  
ctx.env.append_value('CFLAGS', ['-O2'])
#+END_SRC

Les objets =Context= peuvent être davantage modifiés en utilisant le
mécanisme de décorateur Python.

#+BEGIN_SRC Python 
from waflib.Configure import conf

@conf
def get_version (self)
    return 1.1

def configure (ctx):
    v = ctx.get_version()
#+END_SRC 

#+BEGIN_VERSE
Compléter le script avec ces instructions. 
Remplacer le précendent appel à la routine =version= par la méthode interne à l'object =Context=
#+END_VERSE

** Construction

Lors de la phase de construction, les fichiers sources sont compilés
en fichiers objets en suivant des règles définies comme suit: 

#+BEGIN_SRC Python 
def build (ctx):
   ctx (rule="touch ${TGT}", target="a.txt", color='BLUE',always = True)
   ctx (rule="touch ${TGT}", target="b.txt", color='BLUE')
   ctx (rule="cat ${SRC} > ${TGT}", source="a.txt b.txt", target="c.txt", color='PINK')
#+END_SRC 

Les dépendances entre les différentes tâches de construction sont
déduites des entrées / sorties. Dans ce cas, =a.txt= et =b.txt=
doivent être construit avant =c.txt=. =waf= parralélise
automatiquement toutes les tâches qui peuvent l'être. Dans cet exemple
=a.txt= et =b.txt= peuvent être construit simultanément. 

Le nombre maximum de jobs exécutés en parallèle peut être réglé par
l'option =waf -j4= par exemple pour 4 exécuteurs de tâches.

L'option =always= permet de forcer la reconstruction d'un objet
indépendamment des modifications apportées au fichier source.

#+BEGIN_VERSE
Compléter le script avec ces instructions. 
Exécuter la construction de manière séquentielle via la commande =waf step --files=a.txt=, puis parallèle avec =waf build=
#+END_VERSE


** Installation

L'installation est un cas particulier de construction.  Les
instructions spécifiques à l'installation des binaires sur le système
sont écrites dans la routine =build= et peuvent être définies sous la
condition 

#+BEGIN_SRC Python 
def build (ctx):
   if ctx.cmd == 'install':
      files = ctx.path.ant_glob("build/*.txt")
      ctx.install_files('${PREFIX}/txt', files) 
#+END_SRC 

#+BEGIN_VERSE
Compléter le script avec ces instructions. 
Exécuter la commande =waf install= . L'exécution doit retourner une erreur faute de droit suffisant sur le répertoire =prefix= par défaut =/usr/local=. 
Reconfigurer le préfixe via la commande =waf configure --prefix= puis recommencer l'installation. 
#+END_VERSE


** Empaquetage

La commande =waf dist= permet de construire automatiquement une
archive du projet, nommée par défaut =noname-1.0.tar.bz=. 
Pour modifier ce nom, il suffit d'ajouter en tête du script: 

#+BEGIN_SRC Python
APPNAME = "myapp"
VERSION = "1.1"
#+END_SRC

#+BEGIN_VERSE
Compléter le script avec ces instructions. 
Exécuter la commande =waf dist= puis observer le contenu de l'archive. 
#+END_VERSE


* Exemple en C/C++

static
dynamic
use

* Exemple en Python

* Exemple en Fortran

* Gestion des tâches et performances

** Tâches

task generator
#+BEGIN_SRC Python
top = '.'
out = 'build'

def configure(conf):
        pass

def build(bld):
        bld( 1
                rule   = 'cp ${SRC} ${TGT}', 2
                source = 'wscript', 3
                target = 'foobar.txt', 4
        )

#+END_SRC

Rules may be given as expression strings or as python function. The function is assigned to the task class created:
#+BEGIN_SRC Python
top = '.'
out = 'build'

def configure(conf):
        pass

def build(bld):
        def run(task): 1
                src = task.inputs[0].abspath() 2
                tgt = task.outputs[0].abspath() 3
                cmd = 'cp %s %s' % (src, tgt)
                print(cmd)
                return task.exec_command(cmd) 4

        bld(
                rule   = run, 5
                source = 'wscript',
                target = 'same.txt',
        )
#+END_SRC
#+BEGIN_SRC Python
from waflib.Task import Task
class cp(Task): 
   def run(self): 
      return self.exec_command('cp %s %s' % (self.inputs[0].abspath(), 
                                             self.outputs[0].abspath() )    )


def build(ctx):
        t1 = cp(env=ctx.env) 
        t1.set_inputs(ctx.path.find_resource('a.txt')) 
        t1.set_outputs(ctx.path.find_or_declare('b.txt'))
        ctx.add_to_group(t1) 
	
	t1.set_run_after(t2)


from waflib.Task import TaskBase
class task_test_a(TaskBase):
    before = ['task_test_b']
class task_test_b(TaskBase):
    after  = ['task_test_a']

from waflib.Task import TaskBase
class task_test_a(TaskBase):
    ext_in  = ['.h']
class task_test_b(TaskBase):
    ext_out = ['.h']

#+END_SRC
#+BEGIN_SRC Python
import time
from waflib.Task import Task
class copy(Task):

    def run(self):
        return self.exec_command('cp %s %s' % (self.inputs[0].abspath(), self.outputs[0].abspath()))

    def scan(self): 1
        print('→ calling the scanner method')
        node = self.inputs[0].parent.find_resource('wscript')
        return ([node], time.time()) 2

    def runnable_status(self):
        ret = super(copy, self).runnable_status() 3
        bld = self.generator.bld 4
        print('nodes:       %r' % bld.node_deps[self.uid()]) 5
        print('custom data: %r' % bld.raw_deps[self.uid()]) 6
        return ret

def configure(ctx):
    pass

def build(ctx):
    tsk = copy(env=ctx.env) 7
    tsk.set_inputs(ctx.path.find_resource('a.in'))
    tsk.set_outputs(ctx.path.find_or_declare('b.out'))
    ctx.add_to_group(tsk)
#+END_SRC

1       The scanner method is always called on a clean build
2	The scanner method is not called when nothing has changed, although the data returned is retrieved
3	When a dependency changes, the scanner method is executed once again (the custom data has changed) 
#+BEGIN_SRC Python
def configure(ctx):
        ctx.env.COPY      = '/bin/cp'
        ctx.env.COPYFLAGS = ['-f']

def build(ctx):
        from waflib.Task import Task
        class copy(Task):
                run_str = '${COPY} ${COPYFLAGS} ${SRC} ${TGT}'
        print(copy.vars)

        tsk = copy(env=ctx.env)
        tsk.set_inputs(ctx.path.find_resource('wscript'))
        tsk.set_outputs(ctx.path.find_or_declare('b.out'))
        ctx.add_to_group(tsk)
#+END_SRC

** Mesure des performances

=waf= fournit un script permettant de réaliser quelques mesures de
performance, en comparaison avec d'autres outils de construction.

Il s'agit du fichier =genbench.py= qui prend pour argument: 
+ un répertoire pour stocker les fichiers générés
+ un nombre de bibliothèques internes à construire
+ un nombre de classes =C++=  par bibliothèque
+ un nombre d'inclusion de fichier header interne par fichier source
+ un nombre d'inclusion de fichier header de bibliothèques externes par fichier source

Le script génère autant de bibliothèques, classes que spécifié par les
arguments dans le répertoire donné.  Ces fichiers sources sont
accompagnés d'un =wscript= pour construire les objets correspondants. 

#+BEGIN_VERSE
Générer un projet de taille raisonnable  =genbench.py /tmp/build 25 50 5 5= 
Le construire avec un puis 4 exécuteurs de tâches =waf configure build -p -j1=, =waf clean configure build -p -j4=
Mesurer les temps d'exécution à l'aide de la commande =time=. 
#+END_VERSE



* Extensions

** Un exemple



** Ecrire une extension
   
